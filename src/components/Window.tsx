/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.1.4 public/models/window.glb -t
*/

import * as THREE from 'three'
import { useRef } from 'react'
import { useFrame } from "@react-three/fiber";
import { useGLTF } from '@react-three/drei'
import { GLTF } from 'three-stdlib'

type GLTFResult = GLTF & {
  nodes: {
    Mesh1: THREE.Mesh
    Mesh2: THREE.Mesh
    Mesh3_1: THREE.Mesh
    Mesh3_2: THREE.Mesh
    Mesh4_1: THREE.Mesh
    Mesh4_2: THREE.Mesh
    Mesh5_1: THREE.Mesh
    Mesh5_2: THREE.Mesh
    Mesh6_1: THREE.Mesh
    Mesh6_2: THREE.Mesh
    Mesh7: THREE.Mesh
    Mesh8: THREE.Mesh
    Mesh9: THREE.Mesh
    Mesh10: THREE.Mesh
    Mesh11: THREE.Mesh
    Mesh12: THREE.Mesh
    Mesh13: THREE.Mesh
  }
  materials: {
    M_8_natural_pine_light_wood_fine_texture_seamless: THREE.MeshStandardMaterial
    FrontColor: THREE.MeshStandardMaterial
    _Translucent_Glass_Tinted_3: THREE.MeshStandardMaterial
    Formica_Laminate_Dark: THREE.MeshStandardMaterial
  }
}

const Window = function Model(props: any) {
  const { nodes, materials } = useGLTF('/window.glb') as GLTFResult

  const defaultPosition: any = [0, 0, 0];
  const beamAnimationSpeed: any = 0.05;
  const listAnimationSpeed: any = 0.1;

  const topBeamRef: any = useRef();
  const topBeamPosition: any = [0, props.frameValue, 0];
  const topBeamVec: any = new THREE.Vector3(...topBeamPosition);

  const bottomBeamRef: any = useRef();
  const bottomBeamPosition: any =  [0, -props.frameValue, 0];
  const bottomBeamVec: any = new THREE.Vector3(...bottomBeamPosition);

  const leftBeamRef: any = useRef();
  const leftBeamPosition: any =  [props.frameValue, 0, 0];
  const leftBeamVec: any = new THREE.Vector3(...leftBeamPosition);

  const rightBeamRef: any = useRef();
  const rightBeamPosition: any =  [-props.frameValue, 0, 0];
  const rightBeamVec: any = new THREE.Vector3(...rightBeamPosition);

  const topListRef: any = useRef();
  const topListRefFix: any = useRef();
  const topListPosition: any =  [0, props.trimValue, -props.trimValue];
  const topListVec: any = new THREE.Vector3(...topListPosition);

  const leftListRef: any = useRef();
  const leftListRefFix: any = useRef();
  const leftListPosition: any =  [props.trimValue, 0, -props.trimValue];
  const leftListVec: any = new THREE.Vector3(...leftListPosition);

  const bottomListRef: any = useRef();
  const bottomListRefFix: any = useRef();
  const bottomListPosition: any =  [0, -props.trimValue, -props.trimValue];
  const bottomListVec: any = new THREE.Vector3(...bottomListPosition);

  const rightListRef: any = useRef();
  const rightListRefFix: any = useRef();
  const rightListPosition: any =  [-props.trimValue, 0, -props.trimValue];
  const rightListVec: any = new THREE.Vector3(...rightListPosition);


  useFrame(() => {
    topBeamRef.current.position.lerp(topBeamVec, beamAnimationSpeed);
    bottomBeamRef.current.position.lerp(bottomBeamVec, beamAnimationSpeed);
    leftBeamRef.current.position.lerp(leftBeamVec, beamAnimationSpeed);
    rightBeamRef.current.position.lerp(rightBeamVec, beamAnimationSpeed);

    topListRef.current.position.lerp(topListVec, listAnimationSpeed);
    topListRefFix.current.position.lerp(topListVec, listAnimationSpeed);
    bottomListRef.current.position.lerp(bottomListVec, listAnimationSpeed);
    bottomListRefFix.current.position.lerp(bottomListVec, listAnimationSpeed);
    leftListRef.current.position.lerp(leftListVec, listAnimationSpeed);
    leftListRefFix.current.position.lerp(leftListVec, listAnimationSpeed);
    rightListRef.current.position.lerp(rightListVec, listAnimationSpeed);
    rightListRefFix.current.position.lerp(rightListVec, listAnimationSpeed);
  });

  return (
    <group {...props} dispose={null} rotation={[0, -2.5, 0]}>
      <mesh ref={topBeamRef} geometry={nodes.Mesh1.geometry} material={materials.M_8_natural_pine_light_wood_fine_texture_seamless} />
      <mesh ref={bottomBeamRef} geometry={nodes.Mesh2.geometry} material={materials.M_8_natural_pine_light_wood_fine_texture_seamless} />
      
      <mesh ref={topListRef} geometry={nodes.Mesh3_1.geometry} material={materials.M_8_natural_pine_light_wood_fine_texture_seamless} />
      <mesh ref={topListRefFix} geometry={nodes.Mesh3_2.geometry} material={materials.FrontColor} />
      
      <mesh ref={leftListRef} geometry={nodes.Mesh4_1.geometry} material={materials.M_8_natural_pine_light_wood_fine_texture_seamless} />
      <mesh ref={leftListRefFix} geometry={nodes.Mesh4_2.geometry} material={materials.FrontColor} />
      
      <mesh ref={bottomListRef} geometry={nodes.Mesh5_1.geometry} material={materials.M_8_natural_pine_light_wood_fine_texture_seamless} />
      <mesh ref={bottomListRefFix} geometry={nodes.Mesh5_2.geometry} material={materials.FrontColor} />
      
      <mesh ref={rightListRef} geometry={nodes.Mesh6_1.geometry} material={materials.M_8_natural_pine_light_wood_fine_texture_seamless} />
      <mesh ref={rightListRefFix} geometry={nodes.Mesh6_2.geometry} material={materials.FrontColor} />
      
      <mesh ref={leftBeamRef} geometry={nodes.Mesh7.geometry} material={materials.M_8_natural_pine_light_wood_fine_texture_seamless} />
      <mesh ref={rightBeamRef} geometry={nodes.Mesh8.geometry} material={materials.M_8_natural_pine_light_wood_fine_texture_seamless} />
      
      {props.showWindow && <mesh geometry={nodes.Mesh9.geometry} material={materials._Translucent_Glass_Tinted_3} />}
      {props.showWindow && <mesh geometry={nodes.Mesh10.geometry} material={materials.Formica_Laminate_Dark} />}
      {props.showWindow && <mesh geometry={nodes.Mesh11.geometry} material={materials.Formica_Laminate_Dark} />}
      {props.showWindow && <mesh geometry={nodes.Mesh12.geometry} material={materials.Formica_Laminate_Dark} />}
      {props.showWindow && <mesh geometry={nodes.Mesh13.geometry} material={materials.Formica_Laminate_Dark} />}
    </group>
  )
}

useGLTF.preload('/window.glb')

export default Window;